# bind

bind 函数与 `call`,`apply` 的区别是什么呢？

- bind 函数并不是直接调用的
- 参数一 与 `call、apply` 同样，指定的对象（该函数的执行上下文
- 其他参数与 `call` 相同，都作为参数传入，但是 `apply` 只传入一个数组参数

具体对照，可以看我上面的一篇文章，[JavaScript 深入之 call 和 apply 函数]()。

> 1. 判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 `call` 等方式调用的情况
> 2. 保存当前函数的引用，获取其余传入参数值
> 3. 创建一个函数返回
> 4. 函数内部使用 `apply` 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 `this` 给 `apply` 调用，其余情况都传入指定的上下文对象

```javascript
Function.prototype.myBind = function (context) {
  const self = this; // 进行转义
  let argus = [].slice.call(arguments, 1); // 获得第二个参数开始的全部参数
  let fn = function () {}; // 创建一个 fn 作为中间件，防止修改  fBound.prototype 时，也会直接修改绑定函数的 prototype
  let fBound = function () {
    let bindArgus = [].slice.call(arguments);
    return self.apply(
      // 使用的是外层的 this，所有需要在函数内的第一行代码进行转义 const self = this
      this instanceof fn ? this : context,
      argus.concat(bindArgus)
    );
  };
  fn.prototype = this.prototype;
  fBound.prototype = new fn();
  return fBound;
};
```

上面代码中，`return self.apply(...)` 的第一参数是需要注意的

- 在构造函数时，`this instanceof fn` 判断为 true，所以将绑定函数的 `this` 指向该实例

- 在普通函数调用时，这时候的 `this` 指向 `window` ，条件不成立为 false，这时候则将绑定函数的 `this` 指向 `context`

## 文章参考

[JavaScript 深入之 bind 的模拟实现](https://github.com/mqyqingfeng/Blog/issues/12)
