# 对象的扩展

## 属性的简单表示

`ES 6` 允许将属性写在 `{}` 中，直接写入变量和函数，作为对象的属性和方法。这样的书写方式更加简洁。

```javascript
const foo = 'foo';
function getName() {
  console.log('name');
}
const obj = { foo, getName };

console.log(obj); // { foo: 'foo', getName: ƒunction }

// ES 6
const obj = {
  foo: 'foo',
  getName: function () {
    console.log('name');
  },
};
console.log(obj); // { foo: 'foo', getName: function }
```


## 属性的可枚举性和遍历

### 可枚举性

对象的每个属性都有一个描述对象，用来控制该属性的行为。
`Object.getOwnPropertyDescriptor` 方法来获取该属性的描述对象。

```javascript
let obj = { x: 1 };
console.log(Object.getOwnPropertyDescriptor(obj));
// {
//   "value": 1,
//   "writable": true,
//   "enumerable": true,
//   "configurable": true
// }
```

描述对象的 `enumerable` 属性，称为**可枚举性**，如果该属性为 `false`，就会被某些操作忽略。

操作会忽略 `enumerable` 为 `false` 的属性。

- `for...in` 循环：遍历对象自身和继承的可枚举属性。
- `Object.keys()`：返回对象所有可枚举的属性的 `key`。
- `JSON.stringify()`：只串行化对象自身的可枚举的属性。
- `Object.assign()`：只拷贝对象自身的可枚举属性。

### 属性遍历

- **for...in**
  `for...in` 循环对象自身的和继续的可枚举属性

```javascript
let obj = { x: 1, y: 2, z: 3 };
for (let o in obj) {
  console.log(o);
}
// x
// y
// z
```

- **Object.keys(obj)**
  `Object.keys(obj)` 返回一个数组，包含所有可枚举属性的 `key`。

```javascript
let obj = { x: 1, y: 2, z: 3 };
for (let o of Object.keys(obj)) {
  console.log(o);
}
// x
// y
// z
```

- **Object.getOwnPropertyNames(obj)**
  `Object.getOwnPropertyNames(obj)` 返回一个数组，包含对象自身的所有属性的 `key`。

```javascript
let obj = { x: 1, y: 2, z: 3 };
for (let o of Object.getOwnPropertyNames(obj)) {
  console.log(o);
}
// x
// y
// z
```

- **Object.getOwnPropertySymbols(obj)**
  `Object.getOwnPropertySymbols(obj)` 返回一个数组，包含对象自身的所有 `Symbol` 属性的 `key`。
  打印的属性均为 `Symbol`。

```javascript
let obj = { [Symbol('x')]: 1, y: 2, z: 3 };
console.log(Object.getOwnPropertySymbols(obj));
// [Symbol(x)]
```

- **Reflect.ownKeys(obj)**
  `Reflect.ownKeys(obj)` 返回一个数组，包含对象自身所有键名，不管键名是 `Symbol` 或字符串，也不管是否可枚举。

```javascript
let obj = { [Symbol('x')]: 1, y: 2, z: 3, 1: 10, 2: 11 };
console.log(Reflect.ownKeys(obj));
// ['1', '2', 'y', 'z', Symbol(x)]
```

一共五种遍历 `key` 的方式，但是遍历的次序是有规则的。

> - 首先遍历所有数值，并按照升序排列
> - 其次遍历字符串，按照加入时间升序
> - 最后才是 `Symbol`，按照加入时间升序

## 对象的扩展运算符

在 [解构赋值]() 和 [数组的扩展]() 中，我们分别提到过对象的解构赋值以及扩展运算符。

我们来看看扩展运算符在对象中的使用。

### 解构赋值

我们来回顾一下 [解构赋值]() 。

```javascript
let { x, y } = { x: 1, y: 2 };
console.log(x); // 1
console.log(y); // 2
```

- 使用扩展运算符时需要注意的是，解构赋值必须是最后一个参数且只能有一个，否则报错。

```javascript
let { x, ...obj } = { x: 1, y: 2, z: 3 };
console.log(x); // 1
console.log(obj); // { y: 1, z: 2 }

let { ...obj, z } = { x: 1, y: 2, z: 3 };
console.log(obj); // 报错
```

- 对象的解构赋值右侧不能是 `undefined` 或 `null`，会报错

```javascript
let { ...obj } = null;
let { ...obj } = undefined;
// TypeError
```

### 扩展运算符

对象的扩展运算符用于取出参数对象的所有可便利属性，拷贝到当前对象之中。

```javascript
let obj = { x: 1, y: 2 };
let obj2 = { ...obj };
console.log(obj); // { x: 1, y: 2 }
```

- 数组也是特殊的对象，所以对象的扩展运算符也可以用于数组。

```javascript
let obj = { ...['1', '2', '3'] };
console.log(obj);
// { 0: '1', 1: '2', 2: '3' }
```

- 如果是空对象，则没有任何效果。

```javascript
let obj = { ...{}, x: 1 };
console.log(obj); // { x: 1 }
```

- 如果扩展运算符并不是对象，则会被自动转化成对象，但是部分值没有自身属性，所以会返回一个空对象 `{}`。

```javascript
let obj = { ...1 }; // 等同于 { ...Object(1) }
let obj2 = { ...true }; // { ...Object(true) }
let obj3 = { ...undefined }; // { ...Object(undefined) }
let obj4 = { ...null }; // { ...Object(null) }
```

- 如果后面跟着字符串，则会自动转成类数组对象

```javascript
let obj = { ...'hzq' };
console.log(obj); // { 0: 'h', 1: 'z', 2: 'q' }
```
