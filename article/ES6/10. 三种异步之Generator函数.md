# Generator 函数

## 介绍

`Generator` 是 `ES 6` 提供的一种异步编程解决方案。

- 函数定义时，在 `funciton` 后面添加一个星号(`*`)
- 函数体内部使用 `yield` 表达式

```javascript
// 普通函数
function a() {}

// Generator
function* generator() {
  yield 'hello';
  yield 'hzzzzzzzq';
  return 'good';
}

const gen = generator();
gen.next(); // { value: 'hello', done: false }
gen.next(); // { value: 'hzzzzzzzq', done: false }
gen.next(); // { value: 'good', done: true }
gen.next(); // { value: undefined, done: true }
```

`Generator` 函数的调用方式与普通函数是一样的，在函数名后面加上一对圆括号。

- `value` 值显示的是 `yield` 或者 `return` 后面的返回值。
- `done` 是一个布尔值，表示遍历是否结束，`true` 表示结束。
- 当然，`return` 只能有一个，且 `return` 之后不能有 `yield`，因为 `return`，就会让 `done` 变成 `true`。

### yield 表达式

`yield` 表达式就是 Generator 的暂停标志。

- 遇到 `yield` 表达式，就会停止执行后面的操作，`yield` 后面表达式的值，作为返回对象的 `value` 属性值
- 下次调用 `next` 方法时，才会继续执行代码，直到下一个 `yield`
- 如果没有遇到遇到 `yield`，则运行至结束，看是否有 `return`，如果有，则 `return` 后面的值作为返回对象的 `value`
- 如果没有 `yield` 或 `return`，则返回 `value` 为 `undefined`

<!-- 下午需要完善 -->

## next 方法

## for...of 循环

`for...of` 循环可以自动遍历 `Generator` 函数运行时生成的 `Interator` 对象，不需要手动调用 `next` 方法。

```javascript
function* gen() {
  yield 'one';
  yield 'two';
  yield 'three';
  yield 'four';
  return 'five';
}
for (let v of gen()) {
  console.log(v);
}
// one two three four
```

注意：如果 `done` 为 `true`，则会被立刻终止，所有最后一句 `return` 语句不在循环中。

处理 `for...of` 循环之外，扩展运算符，解构赋值和 `Array.from` 方法内部调用的，都是遍历器接口。
都可以将 `Generator` 函数作为返回的 `Interator` 对象，作为参数。

```javascript
function* gen() {
  yield 'one';
  yield 'two';
  yield 'three';
  yield 'four';
  return 'five';
}
console.log([...gen()]);
// ['one', 'two', 'three', 'four']

console.log(Array.from(gen()));
// ['one', 'two', 'three', 'four']

let [x, y, z] = gen();
console.log(x, y, z);
// one two three
```

```javascript
const readFile = function (fileName, ms) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log(fileName);
      resolve(); // 需要给 `Promise` 一个状态转化，就是异步执行是否成功
    }, ms);
  });
};

function* generator() {
  yield readFile('fileName1', 1000);
  yield readFile('fileName2', 2000);
  yield readFile('fileName3', 3000);
  console.log('打印完毕');
}
const gen = generator();
gen.next(); // fileName1
gen.next(); // fileName2
gen.next(); // fileName3
```
