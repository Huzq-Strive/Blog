## 1. Ajax 的四个步骤

- 创建 ajax 实例
- 执行 open 确定要访问的链接 以及同步异步
- 监听请求状态
- 发送请求

## 2. ajax 中 get 和 post 请求的区别

## 3. 状态码

状态码表示了响应的⼀个状态，可以让我们清晰的了解到这⼀次请求是成功还 是失败，如果失败的话，是什么原因导致的，当然状态码也是⽤于传达语义 的。如果胡乱使⽤状态码，那么它存在的意义就没有了

- 2XX 成功
  200 OK ，表示从客户端发来的请求在服务器端被正确处理
  204 No content ，表示请求成功，但响应报⽂不含实体的主体部分
  205 Reset Content ，表示请求成功，但响应报⽂不含实体的主体部分，但是与 204
  响应不同在于要求请求⽅重置内容
  206 Partial Content ，进⾏范围请求
- 3XX 重定向
  301 moved permanently ，永久性重定向，表示资源已被分配了新的 URL
  302 found ，临时性重定向，表示资源临时被分配了新的 URL
  303 see other ，表示资源存在着另⼀个 URL ，应使⽤ GET ⽅法获取资源
  304 not modified ，表示服务器允许访问资源，但因发⽣请求未满⾜条件的情况
  307 temporary redirect ，临时重定向，和 302 含义类似，但是期望客户端保持请求 ⽅法不变向新的地址发出请求
- 4XX 客户端错误
  400 bad request ，请求报⽂存在语法错误
  401 unauthorized ，表示发送的请求需要有通过 HTTP 认证的认证信息
  403 forbidden ，表示对请求资源的访问被服务器拒绝
  404 not found ，表示在服务器上没有找到请求的资源
- 5XX 服务器错误
  500 internal sever error ，表示服务器端在执⾏请求时发⽣了错误
  501 Not Implemented ，表示服务器不⽀持当前请求所需要的某个功能
  503 service unavailable ，表明服务器暂时处于超负载或正在停机维护，⽆法处理请 求

## 4. http

**超文本传输协议（HTTP）**是一个用于传输超媒体文档（例如 HTML）的[应用层](https://en.wikipedia.org/wiki/Application_Layer)协议。它是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的。HTTP 遵循经典的[客户端-服务端模型](https://en.wikipedia.org/wiki/Client–server_model)，客户端打开一个连接以发出请求，然后等待直到收到服务器端响应。HTTP 是[无状态协议](http://en.wikipedia.org/wiki/Stateless_protocol)，这意味着服务器不会在两个请求之间保留任何数据（状态）。尽管通常基于 TCP/IP 层，但它可以在任何可靠的[传输层](https://zh.wikipedia.org/wiki/传输层)上使用，也就是说，该协议不会像 UDP 那样静默的丢失消息。[RUDP](https://en.wikipedia.org/wiki/Reliable_User_Datagram_Protocol)——作为 UDP 的可靠化升级版本——是一种合适的替代选择。

总结一下：

HTTP 是一个应用层协议，用于浏览器和服务器之间通信，通常基于 TCP/IP 层，但是可以在任何传输层上使用。

## 5. https

## 6. http 与 https 区别

## 7. http1.1 与 http 1.0 区别

- 长连接，1.0 打开 tcp/ip 后只发送一个请求，发送完后关闭。1.1 如果制定了 connection：keep-alive（默认），则可以发起 http 请求
- 分块发送 head 和 body，为了节省带宽，1.0 如果 token 过期了，整个报文发送给接收端，返回 401，链接终止。这样请求报文太大，可以先发送 html head 试探，如果是 401 没必要继续发送 body
- 新增 host 字段
- 新增`Chunked transfer-coding`，范围请求，实现断点续传(实际上就是利用 HTTP 消息头使用分块传输编码，将实体主体分块传输)
- 请求管道化，Pipeling 解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，因为传输格式是文本的，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞

## 8. HTTP2.0 和 HTTP1.1 的区别

- 二进制分帧

- 头部压缩：使用 HPACK 对 HTTP/2 头部压缩

- 服务器推送

- **多路复用**：最重要的特点，（MultiPlexing），即连接共享，即每一个 request 都是是用作连接共享机制的。一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面。

  多个请求可同时在一个连接上并行执行（由于支持二进制的格式，可以无序）某个请求任务耗时严重，不会影响到其它连接的正常执行
  http2 与 http1.1 相比有如下几个优点

- 解析速度快

  服务器解析 Http1.1 的请求时，必须不断地读入字节，直到遇到分隔符 CRLF 为止。而解析 HTTP2 的请求就不用这么麻烦，因为 HTTP2 是基于帧的协议，每个帧都有表示帧长度的字段

- 多路复用

  Http1.1 如果要同时发起多个请求，就得建立多个 TCP 连接，因为一个 TCP 连接同时只能处理一个 HTTP。1 的请求。

  在 HTTP2 上，多个请求可以共用一个 TCP 连接，这称为多路复用。同一个请求和响应用一个流来表示，并有唯一的流 ID 来标识。

  多个请求和响应在 TCP 连接中可以乱序发送，到达目的地后在通过流 ID 重新组建

- 首部压缩

  Http2 提供了首部压缩功能，http2 在客户端和服务端使用“首部表”来跟踪和存储之前发送的键值对。对于相同的数据，不再通过每次请求和响应发送。

- 优先级

  Http2 可以对比较紧急的请求设置一个较高的优先级，服务器在收到这样的请求后，可以优先处理

- 流量控制

  由于一个 TCP 连接流量带宽（根据客户端到服务器的网络带宽而定）是固定的，当有多个请求并发时，一个请求占的流量多，另一个请求占的流量就会少。流量控制可以对不同的的流的流量进行精确控制

- 服务器推送

  HTTP2 新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。换句话说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求

  例如当浏览器请求一个网站时，除了返回 HTML 页面外，服务器还可以根据 HTML 页面中的资源的 URL，来提前推送资源。

## 9.TCP 的三次握手和四次挥手

三次握手

第一次握手：客户端发送一个 SYN 码给服务器，要求建立数据连接；
第二次握手： 服务器 SYN 和自己处理一个 SYN（标志）；叫 SYN+ACK（确认包）；发送给客户端，可以建立连接
第三次握手： 客户端再次发送 ACK 向服务器，服务器验证 ACK 没有问题，则建立起连接；

四次挥手

第一次挥手： 客户端发送 FIN(结束)报文，通知服务器数据已经传输完毕；
第二次挥手: 服务器接收到之后，通知客户端我收到了 SYN,发送 ACK(确认)给客户端，数据还没有传输完成
第三次挥手： 服务器已经传输完毕，再次发送 FIN 通知客户端，数据已经传输完毕
第四次挥手： 客户端再次发送 ACK,进入 TIME_WAIT 状态；服务器和客户端关闭连接；

## 10. 为什么建立连接是三次握手，而断开连接是四次挥手呢?

建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。
而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。

## 11. get 和 post 区别

HTTP 协议中的两种发送请求的方法。

HTTP 是什么？ HTTP 是基于 TCP/IP 的关于数据如何在万维网中如何通信的协议。

HTTP 的底层是 TCP/IP。所以 GET 和 POST 的底层也是 TCP/IP，也就是说，GET/POST 都是 TCP 链接。GET 和 POST 能做的事情都是一样的。你要给 GET 加上 request body，给 POST 带上 url 参数，技术上完全行得通的。

GET 和 POST 的一个大区别，

GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包

对于 GET 方式的请求，浏览器会把 `http header` 和 `data` 一并发送出去，服务器响应 200（返回数据）；
对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 pl
也就是说，GET 只需要汽车跑一趟就把货送到了，而 POST 得跑两趟，第一趟，先去和服务器打个招呼"嗨，我等下要送一批货来，你们打开门迎接我"，然后再回头把货送过去。

因为 POST 需要两步，时间上消耗的要多一点，看起来 GET 比 POST 更有效。因此 Yahoo 团队有推荐用 GET 替换 POST 来优化网站性能。但这是一个坑！跳入需谨慎。为什么？

1. GET 与 POST 都有自己的语义，不能随便混用。
2. 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的 TCP 在验证数据包完整性上，有非常大的优点
3. 并不是所有浏览器都会在 POST 中发送两次包，Firefox 就只发送一次

## 12. POST 一定会发送两个 HTTP 请求么

**先说结论，并不是一定，但是大部分是。**

这个涉及到客户端的实现，一般来说，HTTP 请求大致可以分为“请求头”个“请求体”两个部分，一般来说使用 HTTP 时候会默认约定，所有控制类的请求信息放在请求头中，具体数据放在请求体里面。

那么服务端在解析的时候总是会先解析请求头，然后再去决定当前请求如何处理。

所有一般浏览器的方案为：

- 客户端先发送所有请求头的数据给服务器，服务器如果通过，返回 100-continue 字节码，客户端再继续发送请求体。

这样子做好处在于，如果请求体过大，请求一旦失败，浪费大量带宽，如果先发送请求头，直接返回报错，我们就不需要再次发送请求体了，节省带宽。

坏处在于会多一次 Round Trip，如果请求体的数据刚好也不多呢？那么也许一次发送会更好。

因此，很多客户端（浏览器、移动设备等等）会做一些优化，比如内部设定一次 POST 请求的数据超过 1KB 就将请求头和请求体分开发送，如果不超过则一次性发送完成。

甚至，客户端可以做一些策略，加入之前请求的发送成功率很高，那么就总是全部一起发送，如果失败率很高，则全部分开发送，等到成功率上来了，再改动策略。

因此到底是否一次发送两个 HTTP 请求，这并非是 GET 和 POST 的本质区别（很多人愿意将其成为 GET 和 POST 之间的本质区别）无论发几次，这都是客户端的策略而已，是一种实现的优化。
