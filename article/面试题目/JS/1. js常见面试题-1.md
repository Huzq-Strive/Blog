# 常见 JS 面试题

## 1. typeof 和 instanceof 区别

**typeof**

- `typeof` 对于原始类型来说，除了 `null` 都可以显示正确的类型
- `typeof` 对于对象来说，除了函数都会显示 `object` ，所以说 `typeof` 并不能准确判断变量到底是什么类型

**instanceof**

- `instanceof` 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是 能找到类型的 prototype
- 对于原始类型来说，你想直接通过 `instanceof` 来判断类型是不⾏的

## 2. 深拷贝和浅拷贝

- 深拷贝：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。 `JSON.parse、JSON.stringify()`, `递归`, `lodash _.cloneDeep`

- 浅拷贝：拷贝了基础数据，而引用数据拷贝后也会被引用，换句话就是，当拷贝的引用数据修改时，两个会同时修改。 `Object.assign()`, `Array.prototype.concat()`, `扩展运算符`, `Array.prototype.slice()`

## 3. == 和 === 区别

- `==`：返回一个布尔值；相等返回 true，不相等返回 false；
  允许不同数据类型之间的比较；
  如果是不同类型的数据进行，会默认进行数据类型之间的转换；
  如果是对象数据类型的比较，比较的是空间地址
- `===`：只要数据类型不一样就返回 false，不会进行隐式转化

## 4. call bind apply 的区别

- call:

## 5. 闭包

个人感觉，简单来说闭包就是在函数里面声明函数，本质上说就是在函数内部和函数外部搭建起一座桥梁，使得子函数可以访问父函数中所有的局部变量，但是反之不可以，这只是闭包的作用之一，另一个作用，则是保护变量不受外界污染，使其一直存在内存中，在工作中我们还是少使用闭包的好，因为闭包太消耗内存，不到万不得已的时候尽量不使用。
函数里面嵌套函数，而嵌套的函数可以使用外层函数中的参数，但是这变量会一直存在于内存中，导致内存泄漏。

- 闭包有三个特性：1.函数嵌套函数；2.内部函数使用外部函数的参数和变量；3.参数和变量不会被垃圾回收机制回收。
- 闭包的好处：1.希望一个变量长期保存内存中；2.避免全局变量污染；3 私有成员的存在。
- 闭包的缺点：1.常驻内存，增加内存使用量；2.使用不当造成内存泄漏。

## 6. 原型和原型链

- 把所有的对象共用的属性全部放在堆内存的一个对象（共用属性组成的对象）
- 让每一个对象的 `__proto__` 存储这个「共用属性组成的对象」的地址
- 而这个共用属性就是原型，原型出现的目的就是为了减少不必要的内存消耗
- 而原型链就是对象通过 `__proto__` 向当前实例所属类的原型上查找属性或方法的机制
- 如果找到 `Object` 的原型上还是没有找到想要的属性或者是方法则查找结束，最终会返回 `undefined`

## 7. session、cookie、localStorage 的区别

**相同点**

- 都是保存在浏览器端，且同源的。

**不同点**

- cookie 数据始终在同源的 http 请求中携带，即 cookie 在浏览器和服务器间来回传递，而 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存
- cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下
- 存储大小限制也不同，cookie 数据不能超过 4k，同时因为每次 http 请求都会携带 cookie，所以 cookie 只适合保存很小的数据。
- sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；
- localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；
- cookie 只在设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。 作用域不同，sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；
- localStorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的。

## 8. js 中跨域方法

## 9. 前端有哪些页面优化方法?

## 12. 作用域

- 全局作用域

- 块级作用域

## 10. JS 中的同步异步

同步：在同一时间内做一件事情

异步：在同一时间内做多个事情 JS 是单线程的，每次只能做一件事情，JS 运行在浏览器中，浏览器是多线程的，可以在同一时间执行多个任务。

## 11. JS 中常见的异步

setTimeout、ajax、事件绑定、回调函数、async await、promise

## 13. Promise 处理异步

在 `ES 6` 中增加了 `Promise` 对象，我们可以通过 `Promise` 来处理异步事件

`Promise` 对象有三个状态 `pending`(准备)、`fullfilled`(成功)、`rejected`(失败)。
状态一旦经过改变，则无法继续改变。

- **pending -> fullfilled**
- **pending -> rejected**

`Promise` 对象有一个回调函数作为参数，回调函数有 `resolve`，`reject` 两个函数作为参数。
在内部处理异步事件，如果成功则调用 `resolve` 来返回成功的结果，如果失败，则调用 `reject` 来返回失败结果。

而异步则需要通过 `Promise.prototype.then` 方法，来获取结果，而 `then` 方法会在同步代码都执行完之后执行，也就是异步执行。
then 方法最多可以有两个参数：Promise 成功和失败情况的回调函数。

```javascript
new Promise((resolve, reject) => {
  if (true /*异步*/) {
    // 成功，假设返回数据为 data
    const data = '成功';
    resolve(data);
  } else {
    const error = '失败';
    reject(error);
  }
}).then(
  (data) => {
    console.log(data);
  },
  (err) => {
    console.log(err);
  }
);
```

## 15. async await 函数

- async/await 函数是异步代码的新方式

- async/await 是基于 promise 实现的

- async/await 使异步代码更像同步代码

- await 只能在 async 函数中使用，不能再普通函数中使用，要成对出现

- 默认返回一个 promise 实例，不能被改变

- await 下面的代码是异步，后面的代码是同步的

## 16.setTimeout 和 setInterval 的机制

因为 js 是单线程的。浏览器遇到 etTimeout 和 setInterval 会先执行完当前的代码块，在此之前会把定时器推入浏览器的
待执行时间队列里面，等到浏览器执行完当前代码之后会看下事件队列里有没有任务，有的话才执行定时器里的代码

## 14. map 和 forEach 的区别

**相同点**

都是循环遍历数组中的每一项 forEach 和 map 方法里每次执行匿名函数都支持 3 个参数，参数分别是 item（当前每一项）、index（索引值）、arr（原数组），需要用哪个的时候就写哪个匿名函数中的 this 都是指向 window 只能遍历数组

**不同点**
map 方法返回一个新的数组，数组中的元素为原始数组调用函数处理后的值。(原数组进行处理之后对应的数组)
map()方法不会改变原始数组
map()方法不会对空数组进行检测
forEach()方法用于调用数组的每个元素，将元素传给回调函数.(没有 return，返回值是 undefined）

## 17. this 指向

全局作用域下的 this 指向 window
如果给元素的事件行为绑定函数，那么函数中的 this 指向当前被绑定的那个元素
函数中的 this，要看函数执行前有没有 . , 有 . 的话，点前面是谁，this 就指向谁，如果没有点，指向 window
自执行函数中的 this 永远指向 window
定时器中函数的 this 指向 window
构造函数中的 this 指向当前的实例
call、apply、bind 可以改变函数的 this 指向
箭头函数中没有 this，如果输出 this，就会输出箭头函数定义时所在的作用域中的 this

## 18. 数组去重的方法

- 使用数组转 Set，在 Set 转数组
- 使用双重 for 循环（splice 改原始数组 或返回新数组
- indexof 去重，使用新数组，判断是否有重复
- filter 去重

```javascript
// 过滤掉不满足条件的值
const onlyOne = (arr) =>
  arr.filter((item, index) => arr.indexOf(item, 0) === index);
```
